setClassUnion("VecOrNULL", c("vector", "NULL"))
setClassUnion("NumericOrNULL", c("numeric", "NULL"))
setClassUnion("ListOrMatrix", c("list", "matrix"))


#' Class to Store RNA-Seq Read Count Data
#'
#' An S4 class for storing RNA-Seq read count data, including gene or homeolog
#' expression, experimental design, and associated metadata.
#'
#' @slot data A list of read count matrices, with one matrix per subgenome.
#' @slot gene_names A character vector containing gene names.
#' @slot exp_design A data frame describing the experimental design.
#'      It must include a column named `group` indicating sample groupings.
#' @slot meta A list containing additional metadata related to the experiment
#'      or processing steps.
#' 
#' @return An object of class \linkS4class{ExpMX}.
#' @seealso [newExpMX()]
#' @exportClass ExpMX
setClass("ExpMX",
         slots = c(
             data = "ListOrMatrix",
             gene_names = "VecOrNULL",
             exp_design = "data.frame",
             meta = "ANY"
         ))

setValidity("ExpMX", function(object) {
    if (!('group' %in% colnames(object@exp_design)))
        stop('The data.frame `exp_design` ',
             'should contain a column named `group`.')
})


#' Print Contents of an `ExpMX` Object
#'
#' Prints the contents of an `ExpMX` object to the console.
#'
#' @param object An \linkS4class{ExpMX} class object.
#'
#' @return The input \linkS4class{ExpMX} object, returned invisibly.
#'
#' @examples
#' x <- sim_homeolog_counts(100)
#' x
#' 
#' @seealso \linkS4class{ExpMX}
#' @importFrom utils head
#' @importFrom methods show
#' @export
setMethod(
    f = "show",
    signature = "ExpMX",
    definition = function(object) {
        msg <- c('# ', length(object@data), ' subgenome sets', ' (', paste(names(object@data), collapse = ', '),')', '\n',
                 '# ', nrow(object@data[[1]]), ' homeolog tuples', '\n')
        cat(paste(msg, collapse = ''))
        cat('---------------------\n')
        cat('Experiment Design:\n')
        print(object@exp_design)
        cat('---------------------\n')
        for (i in seq_along(object@data)) {
            cat('> subgenome:', names(object@data)[i], '\n')
            print(head(object@data[[i]]))
            if (i != length(object@data)) {
                cat('+++++++++++++++++++++\n')
            } else {
                cat('---------------------\n')
            }
        }
        invisible(object)
})


#' Extract a subset of ExpMX Object
#'
#' Extracts a subset of homeologs or replicates from an `ExpMX` object.
#' 
#' @name [-method
#' @docType methods
#' @rdname subset-ExpMX
#' @aliases [,ExpMX-method
#'
#' @param x An \linkS4class{ExpMX} class object.
#' @param i A logical expression or an integer vector specifying which gene
#'      (rows) to retain.
#' @param j A logical expression or an integer vector specifying which replicate
#'      (columns) to retain.
#' @param ... NOT USED. Included for consistency with the base `[` function.
#' @param drop NOT USED. Included for consistency with the base `[` function.
#'
#' @return A subsetted \linkS4class{ExpMX} class object.
#' 
#' @examples
#' x <- sim_homeolog_counts(n_genes = 100)
#' x_10 <- x[seq_len(10), ]
#' 
#' @seealso \linkS4class{ExpMX}
#' @export
setMethod(
    f = "[",
    signature = "ExpMX",
    definition = function(x, i, j, ..., drop) {
        if (missing(i)) i <- NULL
        if (missing(j)) j <- NULL
        
        i <- .int2logicalvec(i, nrow(x@data[[1]]))
        j <- .int2logicalvec(j, ncol(x@data[[1]]))
        
        for (s in seq_along(x@data)) {
            x@data[[s]] <- x@data[[s]][i, j]
        }
        
        x@gene_names <- x@gene_names[i]
        x@exp_design <- subset(x@exp_design, j)
        
        x
})



#' Combine Homeolog Expression Across Subgenomes
#'
#' Sums homeolog expression values from multiple subgenomes into a single
#' subgenome.
#'
#' An `ExpMX` object stores homeolog expression data for each subgenome as a
#' list of matrices in the `data` slot. This function aggregates selected 
#' subgenome expression matrices into one combined matrix and updates the
#' relevant fields in the `ExpMX` object accordingly.
#'
#' This function is particularly useful for analyzing homeolog expression in
#' species like wheat, which has three subgenomes (commonly named A, B, and D).
#' For example, to analyze the expression ratio between the combined expression
#' of subgenomes A and B versus D, users can apply this function to merge
#' A and B into a single subgenome.
#' 
#' @param x An \linkS4class{ExpMX} class object.
#' @param subgenomes A vector of indices specifying which subgenomes to combine.
#' @param name_to A character string specifying the name of the new combined
#'      subgenome. If not provided, the name will be generated by concatenating
#'      the names of the combined subgenomes.
#'
#' @return An updated \linkS4class{ExpMX} object with the specified subgenomes
#'      combined.
#' 
#' @examples
#' x <- sim_homeolog_counts(n_genes = 100, n_subgenomes = 3)
#' x_combined <- combine_hexp(x, subgenomes = c(1, 2))
#' x_combined
#' 
#' @export
combine_hexp <-function(x, subgenomes, name_to = NULL) {
    combined_data <- vector('list', length = length(x@data) - length(subgenomes) + 1)
    combined_name <- rep('', length = length(combined_data))
    i <- 1
    last_i <- length(combined_data)
    for (s in seq_along(x@data)) {
        if (s %in% subgenomes) {
            if (is.null(combined_data[[last_i]])) {
                combined_data[[last_i]] <- x@data[[s]]
            } else {
                combined_data[[last_i]] <- combined_data[[last_i]] + x@data[[s]]
            }
        } else {
            combined_data[[i]] <- x@data[[s]]
            combined_name[i] <- names(x@data)[s]
            i <- i + 1
        }
    }
    if (is.null(name_to)) {
        combined_name[last_i] <- paste(names(x@data)[subgenomes], collapse = '+')
    } else {
        combined_name[last_i] <- name_to
    }
    
    names(combined_data) <- combined_name
    x@data <- combined_data
    x
}


#' Load Expression Dataset
#'
#' Organize gene expression data into homeolog expression matrices and store
#' them as an `ExpMX` class object.
#'
#' This function arranges the given gene expression matrix
#' into homeolog expression matrices using a mapping table (`mapping_table`),
#' and stores the result as an \linkS4class{ExpMX} class object for downstream analyses.
#'
#' @param x A matrix or data frame of gene expression data,
#'      where each column corresponds to a sample
#'      and each row corresponds to a gene.
#'      The row names should be gene names which match those in the `mapping_table`.
#' @param group A vector or a data frame describing the experimental design.  
#'      If a data frame, it must include a column named `group`
#'      indicating sample groupings.
#' @param mapping_table A data frame
#'      representing the mapping table of homeolog names.  
#'      Each column should correspond to a progenitor genome.
#'  
#' @return An \linkS4class{ExpMX} class object containing homeolog expression data.
#'
#' @examples
#' gexp <- read.table(system.file(package = 'hespresso', 'extdata', 'C_flexuosa.tsv.gz'),
#'                    header = TRUE, sep = '\t', row.names = 1)
#' group <- c('wet', 'wet', 'wet', 'dry', 'dry', 'dry')
#' hnames <- read.table(system.file(package = 'hespresso', 'extdata', 'C_flexuosa.homeolog.tsv.gz'),
#'                      header = TRUE, sep = '\t')
#' expmx <- newExpMX(gexp, group, hnames)
#'
#' @seealso \linkS4class{ExpMX}
#' @export
newExpMX <- function(x, group, mapping_table) {
    if (is.vector(group)) group <- data.frame(group  = group)
    
    n_subgenomes <- ncol(mapping_table)
    x_counts <- vector('list', length = n_subgenomes)
    names(x_counts) <- colnames(mapping_table)
    
    # remove undef genes
    undef_genes <- setdiff(rownames(x), unlist(mapping_table))
    if (length(undef_genes) > 0) {
        warning(length(undef_genes), ' genes in expression data are not defined in mapping table. They will be ignored. ')
        warning('Undefined genes: ', paste(head(undef_genes, 10), collapse = ', '), ifelse(length(undef_genes) > 10, ', ...', ''), '\n')
        x <- x[setdiff(rownames(x), undef_genes), , drop = FALSE]
    }
    
    # find homeolog tuples in expression data
    valid_homeologs <- NULL
    for ( i in seq_len(n_subgenomes)) {
        ids <- seq(1, nrow(mapping_table))
        valid_homeologs <- c(valid_homeologs, ids[(mapping_table[, i] %in% rownames(x))])
    }
    valid_homeologs <- sort(unique(valid_homeologs))
    
    # format
    for (i in seq_len(n_subgenomes)) {
        x_counts[[i]] <- as.matrix(x[mapping_table[valid_homeologs, i], ])
        rownames(x_counts[[i]]) <- NULL
        colnames(x_counts[[i]]) <- NULL
    }
    new("ExpMX",
        data = x_counts,
        gene_names = mapping_table[valid_homeologs, 1],
        exp_design = group,
        meta = NULL)
}




